# Tauri Plugin Development Guide

This reference provides comprehensive guidance for developing Tauri v2 plugins.

## Plugin Architecture

### Directory Structure

A complete Tauri plugin project:

```
tauri-plugin-my-plugin/
├── src/
│   ├── lib.rs              # Plugin entry point and exports
│   ├── commands.rs         # Command implementations
│   ├── error.rs            # Error types
│   ├── models.rs           # Data structures
│   ├── desktop.rs          # Desktop-specific implementation
│   └── mobile.rs           # Mobile-specific implementation (optional)
├── permissions/
│   ├── default.toml        # Default permission set
│   ├── autogenerated/      # Auto-generated command permissions
│   └── schemas/            # Scope schemas (optional)
├── guest-js/
│   ├── index.ts            # TypeScript API bindings
│   └── package.json        # NPM package config
├── build.rs                # Build script for permission generation
├── Cargo.toml
└── README.md
```

### Naming Conventions

| Component | Convention | Example |
|-----------|------------|---------|
| Cargo crate | `tauri-plugin-{name}` | `tauri-plugin-storage` |
| NPM package | `@scope/plugin-{name}` | `@myorg/plugin-storage` |
| Plugin identifier | `{name}` | `storage` |

## Creating a Plugin

### Initialize Project

```bash
npx @tauri-apps/cli plugin new my-plugin
cd tauri-plugin-my-plugin
```

### Plugin Entry Point (lib.rs)

```rust
use tauri::{
    plugin::{Builder, TauriPlugin},
    Manager, Runtime, AppHandle,
};

pub use models::*;

mod commands;
mod error;
mod models;

pub use error::{Error, Result};

/// Plugin state accessible to commands
pub struct MyPlugin<R: Runtime> {
    app: AppHandle<R>,
    config: Config,
}

impl<R: Runtime> MyPlugin<R> {
    pub fn new(app: AppHandle<R>, config: Config) -> Self {
        Self { app, config }
    }

    // Plugin methods
    pub fn do_something(&self) -> Result<()> {
        // Implementation
        Ok(())
    }
}

/// Initialize the plugin
pub fn init<R: Runtime>() -> TauriPlugin<R> {
    Builder::<R, Option<Config>>::new("my-plugin")
        .invoke_handler(tauri::generate_handler![
            commands::store,
            commands::retrieve,
            commands::delete,
        ])
        .setup(|app, api| {
            // Get plugin configuration from tauri.conf.json
            let config = api.config().clone().unwrap_or_default();

            // Initialize plugin state
            let plugin = MyPlugin::new(app.clone(), config);
            app.manage(plugin);

            Ok(())
        })
        .on_navigation(|window, url| {
            // Return false to block navigation
            true
        })
        .on_webview_ready(|window| {
            // Per-window initialization
        })
        .on_event(|app, event| {
            // Handle application events
        })
        .build()
}

/// Extension trait for convenient access
pub trait MyPluginExt<R: Runtime> {
    fn my_plugin(&self) -> &MyPlugin<R>;
}

impl<R: Runtime, T: Manager<R>> MyPluginExt<R> for T {
    fn my_plugin(&self) -> &MyPlugin<R> {
        self.state::<MyPlugin<R>>().inner()
    }
}
```

### Error Handling (error.rs)

```rust
use serde::{Serialize, Serializer};

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("item not found: {0}")]
    NotFound(String),

    #[error("permission denied: {0}")]
    PermissionDenied(String),

    #[error("storage error: {0}")]
    Storage(String),

    #[error("serialization error: {0}")]
    Serialization(#[from] serde_json::Error),

    #[error("io error: {0}")]
    Io(#[from] std::io::Error),
}

impl Serialize for Error {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(self.to_string().as_ref())
    }
}
```

### Data Models (models.rs)

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Default, Deserialize)]
pub struct Config {
    #[serde(default = "default_storage_path")]
    pub storage_path: String,
    #[serde(default)]
    pub encryption_enabled: bool,
}

fn default_storage_path() -> String {
    "data".to_string()
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StoredItem {
    pub key: String,
    pub value: serde_json::Value,
    pub created_at: i64,
    pub updated_at: i64,
}
```

### Commands (commands.rs)

```rust
use tauri::{command, AppHandle, Runtime, State};
use crate::{Error, MyPlugin, Result, StoredItem};

#[command]
pub async fn store<R: Runtime>(
    app: AppHandle<R>,
    plugin: State<'_, MyPlugin<R>>,
    key: String,
    value: serde_json::Value,
) -> Result<()> {
    plugin.store(&key, value).await
}

#[command]
pub async fn retrieve<R: Runtime>(
    plugin: State<'_, MyPlugin<R>>,
    key: String,
) -> Result<Option<StoredItem>> {
    plugin.retrieve(&key).await
}

#[command]
pub async fn delete<R: Runtime>(
    plugin: State<'_, MyPlugin<R>>,
    key: String,
) -> Result<bool> {
    plugin.delete(&key).await
}

// Command with scope restrictions
#[command]
pub async fn list_keys<R: Runtime>(
    plugin: State<'_, MyPlugin<R>>,
    scope: tauri::ipc::CommandScope<crate::Scope>,
) -> Result<Vec<String>> {
    let allowed_prefixes = &scope.allows;
    plugin.list_keys_with_scope(allowed_prefixes).await
}
```

## Permission System

### Build Script (build.rs)

```rust
const COMMANDS: &[&str] = &["store", "retrieve", "delete", "list_keys"];

fn main() {
    tauri_plugin::Builder::new(COMMANDS)
        .global_api_script_path("./api-iife.js")
        .android_path("android")
        .ios_path("ios")
        .build();
}
```

### Default Permissions (permissions/default.toml)

```toml
[default]
description = "Default permissions for my-plugin. Allows basic read operations."
permissions = ["allow-retrieve", "allow-list-keys"]

[[permission]]
identifier = "allow-store"
description = "Allows storing data"
commands.allow = ["store"]

[[permission]]
identifier = "allow-retrieve"
description = "Allows retrieving data"
commands.allow = ["retrieve"]

[[permission]]
identifier = "allow-delete"
description = "Allows deleting data"
commands.allow = ["delete"]

[[permission]]
identifier = "allow-list-keys"
description = "Allows listing keys"
commands.allow = ["list_keys"]

[[permission]]
identifier = "full-access"
description = "Full access to all plugin features"
permissions = ["allow-store", "allow-retrieve", "allow-delete", "allow-list-keys"]
```

### Command Scopes

Define scope schema in `permissions/schemas/scope.json`:

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "prefixes": {
      "type": "array",
      "items": { "type": "string" },
      "description": "Allowed key prefixes"
    }
  }
}
```

Create scoped permissions in `permissions/scoped.toml`:

```toml
[[permission]]
identifier = "user-data-only"
description = "Only access user-prefixed keys"

[[permission.scope.allow]]
prefixes = ["user:"]
```

Access scopes in commands:

```rust
use tauri::ipc::CommandScope;
use schemars::JsonSchema;

#[derive(Debug, Deserialize, JsonSchema)]
pub struct Scope {
    pub prefixes: Vec<String>,
}

#[command]
pub fn scoped_retrieve(
    key: String,
    scope: CommandScope<'_, Scope>,
) -> Result<Option<Value>> {
    // Check if key matches allowed prefixes
    let allowed = scope.allows.iter().any(|s| {
        s.prefixes.iter().any(|prefix| key.starts_with(prefix))
    });

    if !allowed {
        return Err(Error::PermissionDenied(format!(
            "Access to key '{}' not allowed by scope",
            key
        )));
    }

    // Proceed with retrieval
}
```

## TypeScript Bindings

### API Definition (guest-js/index.ts)

```typescript
import { invoke } from '@tauri-apps/api/core';

export interface StoredItem {
  key: string;
  value: unknown;
  createdAt: number;
  updatedAt: number;
}

export interface StoreOptions {
  key: string;
  value: unknown;
}

/**
 * Store a value with the given key.
 *
 * @param key - The key to store the value under
 * @param value - The value to store (must be JSON-serializable)
 * @throws Error if storage fails
 */
export async function store(key: string, value: unknown): Promise<void> {
  await invoke('plugin:my-plugin|store', { key, value });
}

/**
 * Retrieve a value by key.
 *
 * @param key - The key to retrieve
 * @returns The stored item, or null if not found
 */
export async function retrieve(key: string): Promise<StoredItem | null> {
  return await invoke('plugin:my-plugin|retrieve', { key });
}

/**
 * Delete a value by key.
 *
 * @param key - The key to delete
 * @returns true if the item was deleted, false if it didn't exist
 */
export async function remove(key: string): Promise<boolean> {
  return await invoke('plugin:my-plugin|delete', { key });
}

/**
 * List all keys with an optional prefix filter.
 *
 * @param prefix - Optional prefix to filter keys
 * @returns Array of matching keys
 */
export async function listKeys(prefix?: string): Promise<string[]> {
  return await invoke('plugin:my-plugin|list_keys', { prefix });
}
```

### Package Configuration (guest-js/package.json)

```json
{
  "name": "@myorg/plugin-my-plugin",
  "version": "0.1.0",
  "description": "Tauri plugin for persistent storage",
  "main": "dist/index.js",
  "module": "dist/index.mjs",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsup src/index.ts --format cjs,esm --dts",
    "prepublishOnly": "npm run build"
  },
  "peerDependencies": {
    "@tauri-apps/api": "^2.0.0"
  },
  "devDependencies": {
    "tsup": "^8.0.0",
    "typescript": "^5.0.0"
  }
}
```

## Lifecycle Hooks

### Setup Hook

```rust
.setup(|app, api| {
    // Access plugin config
    let config = api.config();

    // Initialize resources
    let db = Database::connect(&config.database_url)?;
    app.manage(db);

    // Start background services
    let handle = app.clone();
    std::thread::spawn(move || {
        background_sync_service(handle);
    });

    Ok(())
})
```

### Navigation Hook

```rust
.on_navigation(|window, url| {
    // Block navigation to external sites
    if url.host_str() != Some("localhost") &&
       url.host_str() != Some("tauri.localhost") {
        tracing::warn!("Blocked navigation to: {}", url);
        return false;
    }
    true
})
```

### Event Hook

```rust
.on_event(|app, event| {
    use tauri::RunEvent;

    match event {
        RunEvent::Ready => {
            tracing::info!("Application ready");
        }
        RunEvent::ExitRequested { api, .. } => {
            // Prevent exit to run cleanup
            api.prevent_exit();

            // Perform cleanup
            if let Some(state) = app.try_state::<MyPlugin>() {
                state.cleanup();
            }

            // Now exit
            std::process::exit(0);
        }
        RunEvent::WindowEvent { label, event, .. } => {
            tracing::debug!("Window '{}' event: {:?}", label, event);
        }
        _ => {}
    }
})
```

### Drop Hook

```rust
.on_drop(|app| {
    // Final cleanup when plugin is destroyed
    if let Some(state) = app.try_state::<MyPlugin>() {
        state.shutdown();
    }
})
```

## Platform-Specific Code

### Desktop Implementation (desktop.rs)

```rust
use tauri::{AppHandle, Runtime};

pub struct DesktopPlugin<R: Runtime> {
    app: AppHandle<R>,
}

impl<R: Runtime> DesktopPlugin<R> {
    pub fn new(app: AppHandle<R>) -> Self {
        Self { app }
    }

    pub fn platform_specific_feature(&self) -> crate::Result<()> {
        // Desktop-only implementation
        #[cfg(target_os = "macos")]
        {
            // macOS-specific code
        }

        #[cfg(target_os = "windows")]
        {
            // Windows-specific code
        }

        #[cfg(target_os = "linux")]
        {
            // Linux-specific code
        }

        Ok(())
    }
}
```

### Mobile Implementation (mobile.rs)

```rust
use tauri::{
    plugin::{PluginApi, PluginHandle},
    AppHandle, Runtime,
};

#[cfg(target_os = "android")]
const PLUGIN_IDENTIFIER: &str = "com.myorg.plugin.myplugin";

#[cfg(target_os = "ios")]
tauri::ios_plugin_binding!(init_plugin_my_plugin);

pub struct MobilePlugin<R: Runtime> {
    #[allow(dead_code)]
    handle: PluginHandle<R>,
}

impl<R: Runtime> MobilePlugin<R> {
    pub fn new<C: serde::de::DeserializeOwned>(
        app: &AppHandle<R>,
        api: PluginApi<R, C>,
    ) -> crate::Result<Self> {
        #[cfg(target_os = "android")]
        let handle = api.register_android_plugin(PLUGIN_IDENTIFIER, "MyPlugin")?;

        #[cfg(target_os = "ios")]
        let handle = api.register_ios_plugin(init_plugin_my_plugin)?;

        Ok(Self { handle })
    }
}
```

## Using Your Plugin

### In Tauri Application (Cargo.toml)

```toml
[dependencies]
tauri-plugin-my-plugin = { path = "../tauri-plugin-my-plugin" }
```

### Registration (lib.rs)

```rust
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_my_plugin::init())
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

### Configuration (tauri.conf.json)

```json
{
  "plugins": {
    "my-plugin": {
      "storage_path": "custom/path",
      "encryption_enabled": true
    }
  }
}
```

### Capabilities (capabilities/default.json)

```json
{
  "identifier": "default",
  "description": "Default capabilities",
  "windows": ["main"],
  "permissions": [
    "my-plugin:default",
    "my-plugin:allow-store"
  ]
}
```

### Frontend Usage

```typescript
import { store, retrieve, remove } from '@myorg/plugin-my-plugin';

// Store data
await store('user:preferences', { theme: 'dark', language: 'en' });

// Retrieve data
const prefs = await retrieve('user:preferences');
console.log(prefs?.value);

// Delete data
const deleted = await remove('user:preferences');
```

## Testing Plugins

### Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_config_defaults() {
        let config: Config = serde_json::from_str("{}").unwrap();
        assert_eq!(config.storage_path, "data");
        assert!(!config.encryption_enabled);
    }

    #[test]
    fn test_error_serialization() {
        let error = Error::NotFound("test".to_string());
        let json = serde_json::to_string(&error).unwrap();
        assert!(json.contains("not found"));
    }
}
```

### Integration Tests

```rust
#[cfg(test)]
mod integration_tests {
    use tauri::test::{mock_builder, MockRuntime};

    fn create_app() -> tauri::App<MockRuntime> {
        mock_builder()
            .plugin(super::init())
            .build(tauri::generate_context!())
            .unwrap()
    }

    #[test]
    fn test_plugin_initialization() {
        let app = create_app();
        assert!(app.state::<super::MyPlugin<MockRuntime>>().inner().is_initialized());
    }
}
```

## Publishing

### Cargo.toml for Publishing

```toml
[package]
name = "tauri-plugin-my-plugin"
version = "0.1.0"
edition = "2021"
description = "Tauri plugin for persistent storage"
license = "MIT OR Apache-2.0"
repository = "https://github.com/myorg/tauri-plugin-my-plugin"
keywords = ["tauri", "plugin", "storage"]
categories = ["development-tools"]

[package.metadata.docs.rs]
all-features = true
rustdoc-args = ["--cfg", "docsrs"]
```

### Publishing Steps

1. Build and test: `cargo build && cargo test`
2. Publish Rust crate: `cargo publish`
3. Build JS bindings: `cd guest-js && npm run build`
4. Publish NPM package: `npm publish`
